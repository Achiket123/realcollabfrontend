/**
 * Represents a User ID (string representation of ObjectId).
 */
type UserId = string;

/**
 * Represents a Task ID (string representation of ObjectId).
 */
type TaskId = string;

/**
 * Represents a Task based on the Mongoose schema.
 */
export interface Task {
  /**
   * The ID of the task.
   */
  _id: TaskId;
  /**
   * The title of the task.
   */
  title: string;
  /**
   * The description of the task.
   */
  description?: string; // Optional description
  /**
   * The status of the task.
   */
  status: 'Pending' | 'In Progress' | 'Completed'; // Updated statuses
  /**
   * The ID of the assigned user.
   */
  assignedTo?: UserId; // Optional assigned user ID
   /**
   * The ID of the user who created the task.
   */
  createdBy: UserId; // Required creator user ID
  /**
   * The due date of the task (ISO string format).
   */
  dueDate?: string; // Optional due date
  /**
   * Timestamp when the task was created.
   */
  createdAt: string;
  /**
   * Timestamp when the task was last updated.
   */
  updatedAt: string;
}

/**
 * Represents a chat message.
 */
export interface ChatMessage {
  /**
   * The ID of the message.
   */
  _id: string;
  /**
   * The ID of the sender.
   */
  sender: UserId; // Assuming this is a user ID
  /**
   * The content of the message.
   */
  content: string;
  /**
   * The timestamp of the message (ISO string format).
   */
  timestamp: string;
  // Potentially add chatRoomId if not inferred from context
  // chatRoom?: string;
}

/**
 * Represents a notification.
 */
export interface Notification {
  /**
   * The ID of the notification.
   */
  _id: string;
  /**
   * The user ID the notification is for.
   */
  user: UserId; // Assuming this is a user ID
  /**
   * The message of the notification.
   */
  message: string;
  /**
   * The type of the notification (e.g., 'task', 'chat', 'file', 'mention').
   */
  type: string;
  /**
   * The related ID (e.g., task ID, chat ID, file ID).
   */
  relatedId?: string; // Optional related ID
  /**
   * The timestamp of when the notification was generated (ISO string format).
   */
  timestamp: string;
  /**
   * Read status
   */
   read?: boolean; // Optional read status
}


// --- API Interaction Functions ---

const API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3000/api';

// Placeholder for getting the auth token (replace with your actual auth logic)
const getAuthToken = (): string | null => {
  // Example: retrieve token from local storage
  if (typeof window !== 'undefined') {
     return localStorage.getItem('authToken');
  }
  return null;
  // return 'your_static_jwt_token_for_testing'; // Or return a static token for testing
};

const getHeaders = (): HeadersInit => {
  const headers: HeadersInit = {
    'Content-Type': 'application/json',
  };
  const token = getAuthToken();
  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }
  return headers;
};

/**
 * Asynchronously retrieves all tasks from the API.
 * @returns A promise that resolves to an array of Task objects.
 * @throws Throws an error if the fetch operation fails.
 */
export async function getAllTasks(): Promise<Task[]> {
  console.log('Fetching tasks from API...');
  const response = await fetch(`${API_BASE_URL}/task/all`, {
     method: 'GET',
     headers: getHeaders(),
  });

  if (!response.ok) {
    const errorData = await response.json().catch(() => ({ message: 'Failed to fetch tasks' }));
    console.error('API Error:', response.status, errorData);
    throw new Error(errorData.message || `Failed to fetch tasks (${response.status})`);
  }

  const data = await response.json();
  // The API seems to return the array directly based on the route handler logic provided
  return data as Task[];
}

/**
 * Type for creating a new task. Excludes fields generated by the backend.
 */
export type CreateTaskData = Omit<Task, '_id' | 'createdBy' | 'createdAt' | 'updatedAt'> & {
  // createdBy will be added by the backend based on the auth token
  // Make assignedTo optional if it's not always required at creation
   assignedTo?: UserId;
};

/**
 * Creates a new task via the API.
 * @param taskData The data for the new task.
 * @returns A promise that resolves to the created Task object.
 * @throws Throws an error if the creation fails.
 */
export async function createTask(taskData: CreateTaskData): Promise<Task> {
   console.log('Creating task:', taskData);
  const response = await fetch(`${API_BASE_URL}/task/create`, {
    method: 'POST',
    headers: getHeaders(),
    body: JSON.stringify(taskData),
  });

  if (!response.ok) {
     const errorData = await response.json().catch(() => ({ message: 'Failed to create task' }));
     console.error('API Error:', response.status, errorData);
    throw new Error(errorData.message || `Failed to create task (${response.status})`);
  }
  return response.json();
}

/**
 * Type for updating an existing task. All fields are optional except _id.
 */
 export type UpdateTaskData = Partial<Omit<Task, '_id' | 'createdBy' | 'createdAt' | 'updatedAt'>>;


/**
 * Updates an existing task via the API.
 * @param taskId The ID of the task to update.
 * @param taskData The data to update the task with.
 * @returns A promise that resolves to the updated Task object.
 * @throws Throws an error if the update fails.
 */
export async function updateTask(taskId: TaskId, taskData: UpdateTaskData): Promise<Task> {
  console.log(`Updating task ${taskId}:`, taskData);
  const response = await fetch(`${API_BASE_URL}/task/update/${taskId}`, {
    method: 'PUT',
    headers: getHeaders(),
    body: JSON.stringify(taskData),
  });

  if (!response.ok) {
     const errorData = await response.json().catch(() => ({ message: 'Failed to update task' }));
     console.error('API Error:', response.status, errorData);
    throw new Error(errorData.message || `Failed to update task (${response.status})`);
  }
  return response.json();
}

/**
 * Deletes a task via the API.
 * @param taskId The ID of the task to delete.
 * @returns A promise that resolves when the deletion is successful.
 * @throws Throws an error if the deletion fails.
 */
export async function deleteTask(taskId: TaskId): Promise<{ message: string }> {
   console.log(`Deleting task ${taskId}`);
  const response = await fetch(`${API_BASE_URL}/task/delete/${taskId}`, {
    method: 'DELETE',
    headers: getHeaders(),
  });

  if (!response.ok) {
     const errorData = await response.json().catch(() => ({ message: 'Failed to delete task' }));
     console.error('API Error:', response.status, errorData);
    throw new Error(errorData.message || `Failed to delete task (${response.status})`);
  }
  return response.json(); // Expecting { message: "Task deleted successfully" } or similar
}


// --- Mock Data Functions (Keep for Chat/Notifications until integrated) ---

/**
 * Asynchronously retrieves all chat messages for a given chat room.
 * MOCK IMPLEMENTATION.
 * @param chatRoomId The ID of the chat room.
 * @returns A promise that resolves to an array of ChatMessage objects.
 */
export async function getAllChatMessages(chatRoomId: string): Promise<ChatMessage[]> {
   console.log(`Mock fetching messages for room: ${chatRoomId}...`);
   // Simulate API call delay
   await new Promise(resolve => setTimeout(resolve, 300));

  // TODO: Replace with actual fetch call:
  // const response = await fetch(`${API_BASE_URL}/messages/${chatRoomId}`); // Example endpoint
  // if (!response.ok) {
  //   throw new Error(`Failed to fetch messages for room ${chatRoomId}`);
  // }
  // const data = await response.json();
  // return data.messages;

  // Return different messages based on room ID for demo
  if (chatRoomId === 'project1') {
    return [
       { _id: 'p1_m1', sender: 'user1', content: 'Okay, starting work on the auth flow now.', timestamp: new Date(Date.now() - 60000 * 10).toISOString() },
       { _id: 'p1_m2', sender: 'user2', content: 'Great! I\'ll begin the schema design.', timestamp: new Date(Date.now() - 60000 * 9).toISOString() },
     ];
  } else if (chatRoomId === 'user2') {
     return [
       { _id: 'u2_m1', sender: 'currentUser', content: 'Hey Alice, quick question about the API.', timestamp: new Date(Date.now() - 60000 * 2).toISOString() },
     ];
  }

  return [ // Default for 'room1' or others
    { _id: 'gen_m1', sender: 'admin', content: 'Welcome to the general discussion!', timestamp: new Date(Date.now() - 60 * 60 * 1000).toISOString() }, // 1 hour ago
    { _id: 'gen_m2', sender: 'user1', content: 'Anyone seen the latest project update?', timestamp: new Date(Date.now() - 30 * 60 * 1000).toISOString() }, // 30 mins ago
  ];
}

/**
 * Asynchronously retrieves all notifications for a given user.
 * MOCK IMPLEMENTATION.
 * @param userId The ID of the user.
 * @returns A promise that resolves to an array of Notification objects.
 */
export async function getAllNotifications(userId: string): Promise<Notification[]> {
   console.log(`Mock fetching notifications for user: ${userId}...`);
   // Simulate API call delay
   await new Promise(resolve => setTimeout(resolve, 400));

   // TODO: Replace with actual fetch call:
   // const response = await fetch(`${API_BASE_URL}/notifications/${userId}`); // Example endpoint
   // if (!response.ok) {
   //   throw new Error(`Failed to fetch notifications for user ${userId}`);
   // }
   // const data = await response.json();
   // return data.notifications;

  return [
    {
      _id: 'notif_1',
      user: userId,
      message: 'Task "Design Database Schema for Chat" assigned to you.',
      type: 'task',
      relatedId: 'task_2', // This ID might need updating if mock tasks change
      timestamp: new Date(Date.now() - 5 * 60 * 1000).toISOString(), // 5 mins ago
      read: false,
    },
    {
      _id: 'notif_2',
      user: userId,
      message: 'Admin mentioned you in #general discussion.',
      type: 'mention', // Example new type
      relatedId: 'room1', // Link to chat room
      timestamp: new Date(Date.now() - 15 * 60 * 1000).toISOString(), // 15 mins ago
      read: false,
    },
    {
      _id: 'notif_3',
      user: userId,
      message: 'New file "API_Documentation_v2.pdf" uploaded to Project Alpha.',
      type: 'file',
      relatedId: 'file_xyz', // Example file ID
      timestamp: new Date(Date.now() - 60 * 60 * 1000).toISOString(), // 1 hour ago
      read: true, // Example of a read notification
    },
  ];
}